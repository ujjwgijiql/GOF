# Gang of Four Design Patterns

设计模式：是指在软件开发过程中，经过验证的，用于解决在特定环境下、重复出现的、特定问题的解决方案。

创建型：抽象了对象实例化过程，用来帮助创建对象的实例。
        简单工厂模式
        Singleton(单例模式)
        Factory Method(工厂方法模式)
        Abstract Factory(抽象工厂模式)
        Builder(生成器模式)
        Prototype(原型模式)

结构型：描述如何组合类和对象以获得更大的结构。
        Facade(外观模式)
        Adapter(适配器模式)
        Proxy(代理模式)
        Composite(组合模式)
        Flyweight(享元模式)
        Decorator(装饰模式)
        Bridge(桥接模式)

行为型：描述算法和对象间职责的分配。
        Mediator(中介者模式)
        Observer(观察者模式)
        Command(命令模式)
        Iterator(迭代器模式)
        Template Method(模板方法模式)
        Strategy(策略模式)
        State(状态模式)
        Memento(备忘录模式)
        Interpreter(解释器模式)
        Chain of Responsibility(职责链模式)
        Visitor(访问者模式)





。Facade(外观模式)
    为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加
容易使用。
    目的不是给子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦合，从而让外
部能够更简单地使用子系统。
  
  。外观模式与中介者模式
      中介都模式主要用来封闭多个对象之间相互的交互，多用在系统内部的多个模块之间；外观模式封闭的是单
向的交互，是从客户端访问系统的调用，没有从系统来访问客户端的调用。
      在中介者模式的实现里面，是需要实现具体的交互功能的；而外观模式的实现里面，一般是组合调用或是转
调内部实现的功能，通常外观模式并不实现这些功能。
      中介者模式的目的主要是松散多个模块的耦合，把这些耦合关系全部放到中介者中去实现；而外观模式的目
的是简化客户端的调用。

  。外观模式和单例模式
      通常一个子系统只要一个外观实例，所以外观模式可以和单例模式组合使用。

  。外观模式和抽象工厂模式





。Adapter(适配器模式)
    将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些
类可以一起工作。
    适配器模式的主要功能是进行匹配转换，目的是复用已有的功能，而不是来实现新的接口。

  。优点
    更好的复用性
    更好的可扩展性
  。缺点
    过多地使用适配器，会让系统非常零乱，不容易整体进行把握。

  。适配器模式与桥接模式
      除了结构略为相似外，功能上完全不同。
      适配器模式是把两个或者多个接口的功能进行转换匹配；而桥接模式是让接口和实现部分相分离，以便他们
可以相对独立地变化。

  。适配器模式与装饰模式
      从某种意义上讲，适配器模式能模拟实现简单的装饰模式的功能，也就是为已有功能增添功能。
      两个模式有一个很大的不同：一般适配器适配过后是需要改变接口的，如果不改接口就没有必要适配了；而
装饰模式是不改变接口的，无论多少层装饰都是一个接口。因此装饰模式可以很容易地支持递归组合，而适配器就
做不到，每次的接口不同，无法递归。

  。适配器模式和代理模式
      适配器模式可以和代理模式组合使用。在实现适配器的时候，可以通过代理来调用Adapter，这样可以获得更
大的灵活性。

  。适配器模式和抽象工厂模式
      在适配器实现的时候，通常需要得到被适配的对象。如果被适配的是一个接口，那么就可以结合一些可以创
造对象实例的设计模式，来得到被适配的对象示例，比如抽象工厂模式、单例模式、工厂方法模式等。





。Singleton(单例模式)
    单例模式是用来保证这个类在运行期间只会被创建一个类实例，另外，单例模式还提供了一个全局别唯一访问
这个类实例的访问点，就是getInstance方法。
    对于单例模式而言，不管采用何种实现方式，它都是只关心类实例的创建问题，并不关心具体的业务功能。

  。双重检查加锁
      需要使用关键字volatile,被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直
接操作共享内存，从而确保多个线程能正确的处理该变量。
      public class Singleton {
          private volatile static Singleton instantce = null;

          private Singleton() {
          }

          public static Singleton getInstance() {

              if (instance == null) {
                  synchronized(Singleton.class) {
                      if (instance == null) {
                          instance = new Singleton();
                      }
                  }
              }
          }
      }

      由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。一般情况下，
没有特别的需要，不要使用。

Lazy initialization holder class模式，综合使用了java的类级内部类和多线程缺省同步锁，很巧妙地同时实现
了延迟加载和线程安全。
      多线程缺省同步锁：在某些情况中，JVM已经隐含地为你执行了同步，这些情况下就不用自己再来同步控制了。
      。由静态初始化器(在静态字段上或static{}块中的初始化器)初始化数据时
      。访问final字段时
      。在创建线程之前创建对象时
      。线程可以看见它将要处理的对象时

      public class Singleton {
          
          /** 类线内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，而且只
           * 有被调用到时才会装载，从而实现了延迟加载
           */
          private static class SingletonHolder {

              /**
               * 静态初始化器，由JVM来保证线程安全
               */
              private static Singleton instance = new Sinleton();
          }

          /**
           * 私有化构造方法
           */
          private Singleton() {
          }

          public static Singleton getInstance() {
              return SingletonHolder.instance;
          }
      }





。Factory Method(工厂方法模式)
